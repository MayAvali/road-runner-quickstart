package org.firstinspires.ftc.teamcode.team.subsystems;

import com.acmerobotics.roadrunner.Action;
import com.acmerobotics.roadrunner.InstantAction;
import com.acmerobotics.roadrunner.InstantFunction;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.acmerobotics.dashboard.config.Config;


public class ScoringSystem {
    private final DcMotorEx launcher;
    //private final DcMotorEx intake2;
    private final DcMotorEx intake;
    //private final VoltageSensor voltageSensor;
    private final DcMotorEx turret;

    private final DcMotorEx launcher2;

    @Config
    public static class intakePIDF {
        public static double P = 16;
        public static double I = 0;
        public static double D = 0;
        public static double F = 12;
    }
    @Config
    public static class launcherPIDF {
        public static double P = 115;
        public static double I = 0;
        public static double D = 0;
        public static double F = 16;
    }
    @Config
    public static class turretPIDF {
        public static double P = 12;

        public static double I = 0.5;
        public static double D = 0.5;
        public static double F = 24;
    }
    public static launcherPIDF LauncherPIDF = new launcherPIDF();
    public static intakePIDF IntakePIDF = new intakePIDF();
    public static turretPIDF TurretPIDF = new turretPIDF();


    public double LaunchVel = 1200;
    public double LaunchMult = 0.88;

    public ScoringSystem(DcMotorEx launcher, DcMotorEx intake, DcMotorEx turret, DcMotorEx launcher2) {
        this.launcher = launcher;
        this.launcher2 = launcher2;
        launcher.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
        launcher2.setDirection(DcMotorSimple.Direction.REVERSE);
        launcher.setVelocityPIDFCoefficients(launcherPIDF.P, launcherPIDF.I, launcherPIDF.D, launcherPIDF.F);
        //this.voltageSensor = voltageSensor;

        this.intake = intake;

        intake.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
        intake.setDirection(DcMotorSimple.Direction.REVERSE);
        intake.setVelocityPIDFCoefficients(intakePIDF.P, intakePIDF.I, intakePIDF.D, intakePIDF.F);

        this.turret = turret;
        turret.setDirection(DcMotorSimple.Direction.REVERSE);
        turret.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        turret.setTargetPosition(0);
        turret.setTargetPositionTolerance(1);
        turret.setMode(DcMotorEx.RunMode.RUN_TO_POSITION);
        turret.setDirection(DcMotorSimple.Direction.REVERSE);
        turret.setPower(1);
        turret.setPositionPIDFCoefficients(10);
        turret.setVelocityPIDFCoefficients(turretPIDF.P,turretPIDF.I,turretPIDF.D,turretPIDF.F);
    }

    public void launcherOff(){
        launcher.setVelocity(0);
        launcher2.setPower(launcher.getPower());
    }

    public Action launcherOffAction(){
        return new InstantAction(
                this::launcherOff
        );
    }
    public void launcherUpdate(){
        launcher.setVelocity(LaunchVel);
        launcher.setVelocityPIDFCoefficients(launcherPIDF.P, launcherPIDF.I, launcherPIDF.D, launcherPIDF.F);
        launcher2.setPower(launcher.getPower());
        //launcher.setPower(LaunchMult*(12/(voltageSensor.getVoltage())));
    }

    public Action launcherUpdateAction(){
        return new InstantAction(
                this::launcherUpdate
        );
    }
    public static double TurretDistToFlywheelVelocity (double distance) {
        return 0.0000395906*Math.pow((distance), 2)+ 0.0754783*(distance) + 976.44332;
    }
    //Used Odometry Distance

    public void launchVelAdjust(int input){
        LaunchVel += input;
    }

    public void setLaunchVel(int velocity){
        LaunchVel = velocity;
    }

    public void intake(double out, double in){
        intake.setVelocityPIDFCoefficients(intakePIDF.P, intakePIDF.I, intakePIDF.D, intakePIDF.F);
        //intake2.setVelocityPIDFCoefficients(intakePIDF.P, intakePIDF.I, intakePIDF.D, intakePIDF.F);
        intake.setVelocity((2800*out)-(3600*in));
    }

    public Action intakeAction(double out, double in) {
        return new InstantAction(
                () -> this.intake(out, in)
        );
    }

    public void setTurretTarget(double inputDegrees, double totalTicks) {
        double ticksPerDegree = totalTicks / 360.0;
        double targetTicks = inputDegrees * ticksPerDegree;
        double limit = 0.25 * totalTicks;
        double clampedPosition = Math.max(-limit, Math.min(targetTicks, limit));
        turret.setTargetPosition((int) clampedPosition);
    }


    public double getTurretPos() {
        return turret.getCurrentPosition();
    }
    public double getTurretTargetPos(){
        return turret.getTargetPosition();
    }
    public double getTurretPower(){
        return turret.getPower();
    }
    public double getIntakeVel() {
        return intake.getVelocity();
    }
    public double getLauncherVel() {
        return launcher.getVelocity();
    }
}
